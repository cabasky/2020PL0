PL0实验小结
===============

一.注释语句
---------------

* 为了注释功能，添加了三个语法符号  

```
 /*   SYM_BLOCKEXPLBEG   段落注释开始符号
 */   SYM_BLOCKEXPRBEG   段落注释结束符号
 //   SYM_LINEEXPL       行注释开始符号
```
* 词法分析代码如下
```c++
	else if(ch=='/'){
		getch();
		if(ch=='/'){
			sym=SYM_LINEEXPL;
			while(cc!=ll) getch();
			getsym();
		}
		else if(ch=='*'){
			sym=SYM_BLOCKEXPLBEG;
			blockExplanation();
			getsym();
		}
		else sym=SYM_SLASH;
	}
```

可以看出，处理的时候，如果遇到一个行注释符号，则一直往后读取到换行符为止，相当于跳过本行之后的分析，防止被语法分析器分析注释内容；

* 而读到块注释符号的开始，则进入blockExplanation函数，函数实现如下：
```c++
void blockExplanation(){
	int status=0;
	do{
		getch();
		if(status==0){
			if(ch=='*') status=1;
		}
		else if(status==1){
			if(ch=='/') status=2;
			else status=0;
		}
	}while(status!=2);
	getch();
}
```
意为读取段落注释起始符号之后的第一个段落注释终止符号，并且匹配，防止被文法分析器读取。
因此，在本程序的处理逻辑中，注释的文法效果相当于一个换行符。

二.逻辑运算符 与 或 非
-------------
* 首先，需要增加三个符号，以及相对应的OPR操作负号
```
	!	逻辑非
	&&	逻辑与
	||	逻辑或
```
* 优先级从上到下递减，并且一般遵从c语言的优先级规则，也就是优先级：
```
	单目非 > 算数运算符 > 关系运算符 > 且 > 或
```
* 以下是词法实现：
```c++
	else if(ch=='&'){
		getch();
		if(ch=='&'){
			sym=SYM_AND;
			getch();
		}
		else{
			sym=SYM_ADR;
		}
	}//此处判断接收的是与运算符或者取地址符号，如果连续读入两个&，则说明是逻辑与


	else if(ch=='|'){
		getch();
		if(ch=='|'){
			sym=SYM_OR;
			getch();
		}
		else{
			printf("Fatal Error: Unknown character.\n");
			exit(1);
		}
	}//此处接收两个｜符号，认为读入了一个逻辑或运算符；如果读到单个｜符号，则说明出错
```
而单目的非运算符！直接写入符号表，在所有多字节符号分析结束后比对来读取。

* 关于文法实现，由于pl0采用LL(1)分析机，大体上当函数A内部调用函数B时，可以说明B优先规约，优先级大于A。因此，我们加入两个函数，套用在已经实现好的condition()外面来实现优先级。
```c
void andcondition(symset fsys){
	condition(fsys);
	while(sym==SYM_AND){
		getsym();
		condition(fsys);
		gen(OPR,0,OPR_AND);
	}
}//表示逻辑与连接的表达式串，并在内部调用pl0已经实现好的“条件”文法
void orcondition(symset fsys){
	andcondition(fsys);
	while(sym==SYM_OR){
		getsym();
		andcondition(fsys);
		gen(OPR,0,OPR_OR);
	}
}//表示逻辑或连接的表达式串，并在内部调用andcondition，实现优先级
```
同时，在原来的pl0程序里，将所有调用condition的地方都替换成orcondition，这样文法就能从最低级的逻辑或运算符开始分析。

* 关于逻辑非的文法实现，和负号在统一级用类似的方法实现，分析的方法写入到factor文法中，表示和负号同优先级右结合。

三.引用变量
-----------
* 总体上，本程序中引用变量是一类新的标识符，类型为ID_ACTUAL，内部存储的是指向的地址。当在普通的赋值表达式中用到引用变量的时候，会读取引用变量指向的地址，从地址中读取被引用的值。
* 因此，我们需要增加几个新的指令
```
	ADR		计算变量的真实地址，存放在栈顶，相当于x86中的LEA

	STA		操作数为一个地址，读取这个地址中的值，作为一个新的地址，将栈
			顶的数据存入这个新地址中，相当于一次间接写入的STO

	LOA		操作数为一个地址，读取这个地址中的值，作为一个新的地址，读取
			新地址中的值，存入栈顶，相当于一次间接读取的LOD
```
同时，增加了一些类似以上三条的新指令，不过会直接在取栈顶的多个操作数操作，结果存在新的栈顶。

* 和c类似，引用变量需要赋初始值，该初始值必须是已经定义的变量、引用变量或者数组元素。在程序实现时，定义了一个refer数组来存储引用变量的引用信息。由于编写本程序时认为左值表示比较单一（也就是引用的只能是单个标识符或者数组元素，但不能是一个表达式），因此实现的时候是用直接分类讨论的，并没有引入文法，这也是本程序可以改进的地方。
* 引用变量的赋值由于需要会有跨层调用、调用数组下标含变量的问题，因此并不能在编译的时候直接将真实地址写死到程序中，而是先开辟空间，然后依次生成赋值指令并执行，对一般的引用可以分成以下三种情况：


```
	1.引用了一个普通变量，即var a,&b=a
		分析的时候，将被指向的变量a在编译器的符号表下标写入refer[b]中；
		生成指令的时候，直接将refer[b]里的变量a的偏移地址用ADR指令计算好放在栈顶，然后用LOD指令写入到b所在的内存中。

	2.引用了一个引用变量，即var a,&b=a,&c=b
		分析的时候，将refer[b]写入到refer[c]中，表示b和c事实上指向同一块地址；
		生成指令的时候，方法和普通变量就相同了，因为此时refer[c]也为a
	
	3.引用了一个数组元素，即var a[10],&b=a[3]
		此时b的refer只能为a的首地址；
		生成指令的时候，首先用ADR指令计算a的真实首地址，写入到栈顶，然后调用一个数组下标文法分析函数findAddress，生成一串数组的三地址计算指令，将栈顶的内容改写为真实的数组元素下标，最后用LOD存入b中。
```

* 关于如何调用引用变量和在程序中对引用变量赋值，由于程序中都为单层引用，所以生成指令的时候只需要类比普通变量，将STO改为STA，LOD改成LOA即可。

四.函数调用和参数传递
-----------

* 总体来说，函数声明和调用的语法和c类似，但是不需要规定类型。函数的参数可以是普通变量、引用变量、数组，用法和c++基本相同。
* 函数参数作为一类特殊的变量，在本程序中，拥有负数的偏移量，以此来区分函数参数和其他变量。做出这样的区分，主要是因为引用变量在赋初始值的时候，如果被引用的是一个函数参数，由于事先不知道传入的地址是多少，因此要和上面三种引用初始值的赋值做出一些区分。大体上，改动就是用LOD指令取出参数里的值（事实上是指向的地址），然后存入引用变量自身所占的空间里。
```
	1.引用了一个普通变量，即var &b=a，a为一个函数参数
		没有改动，只需要计算访问链，加上负数的偏移就可以。

	2.引用了一个引用变量，即var &b=a，a是一个作为函数参数传入的引用变量
		函数在调用时传入引用变量a，实际上是将引用变量指向的地址存到a里面。
		因此，用LOD指令（之前用的是ADR）取出传入到a里的地址，用STO存入到b的空间中。
	
	3.引用了一个数组元素，即var &b=a[3]，a从函数参数传入
		数组作为参数传入时，传入的是首地址，因此用LOD取出，然后调用findAddress生成偏移计算指令，最后STO存入b中
```
按照这样的完整赋值规则，函数的嵌套和递归都可以正常实现。

* 关于函数的调用，这里以p(a,b,c)为例，这三个参数的偏移量分别为-3，-2，-1；调用时，将参数按照正序压入栈中（这里和c语言正好相反，因为方便顺序语法分析，也因为pl0的栈正增长）
* 函数并没有返回值，因此不能作为表达式的一部分，这里可以改进。
* 在编程中遇到过这样的问题：生成局部引用变量赋值指令的时候需要栈上的临时空间，同时每个局部变量需要分配空间。如果先赋初始值而后用INT分配空间，会导致临时空间占用局部变量的情况；如果每赋完值就INT 1表示依次为每个变量分配空间，解决了上述问题，但导致指令冗杂；如果先INT分配空间，后为引用变量赋初始值，由于在语法分析的时候不知道总共有多少局部变量，INT指令的操作数不确定，所以只能先读完统计局部变量数量，这导致代码实现及其复杂。最简单的解决方式是：先生成INT，操作数为0，然后语法分析，生成赋值语句，并统计局部空间，最后用回填的方式填入最早生成的INT指令。

附录：精彩部分  
------------
1.为每个函数开了一个链表来存参数，在函数分析结束后，只清空符号表，不清空这个链表，用于调用的时候来查询信息。对于调用这种上下文有关的文法，这是为了避免函数在分析结束后，参数清空而查不到参数信息。但由于链表本身的倒序特性，需要多一步逆序转换。  
2.数组的下标信息完全用链表实现。这里正好运用了由于链表的倒序特性，可以递归地将链表一次性计算成下一级下标的总偏移量之积，代码实现简单而且优美，更方便了生成乘法指令的时候直接取出下一级偏移量相乘，而且可以方便了错误分析（链表没结束而数组下标已经分析完、链表结束了但数组下标还没分析完）
3.程序生成了便于调试的stacktest文件，用于观察运行栈信息